= Seed  User Guide
Emily Smith <emily.smith@appliedis.com>; Jonathan Meyer <jonathan.meyer@appliedis.com>; Matt Anderson <matt.anderson@appliedis.com>
:toc: left
:toclevels: 5
:stylesheet: styles/html.css
:sectlinks:
:sectnums:
:sectnumlevels: 5
:icons: font
:docinfo:
:seed-spec-url: https://ngageoint.github.io/seed/seed.html
:vault-url: https://www.vaultproject.io/

== Purpose

This guide introduces data scientists and algorithm developers to the Seed and Scale technologies developed at the
National Geospatial-Intelligence Agency (NGA) Research. These technologies optimize algorithm development
from proof of concept to operational execution within distributed processing clusters.

*TODO: Docker -> Seed -> Scale diagram*

Seed is a general {seed-spec-url}[standard] to aid in the discovery and consumption of 
a discrete unit of work contained within a Docker image. Seed allows data scientists to focus their expertise on solving 
domain problems and provides tools to ensure their algorithm is packaged properly for operational use. Seed can be used 
throughout the development lifecycle to build, test and package within a simulated environment that closely emulates 
targeted operational environments. This reduces risk and allows the algorithm requirements to be explicitly defined by 
the developers who best understand their processing needs.

Scale is a distributed processing framework for near real-time processing of large data sets. It frees data scientists 
and algorithm developers from the complexity of distributed system concepts and offers an
integration platform for highly parallel processing of data. Scale also ensures decision makers and system
administrators are able to visually monitor data flows and ensure reliable data processing.  It enables a true DevOps
environment for algorithm development and cloud transition.

This document will focus primarily on using the Seed Command-Line Interface (CLI) to build, test and publish your
algorithm as a Seed compliant Docker image. The Seed toolchain consists of the CLI, Silo, Vault and any processing
system that can consume Seed images - Scale being the primary one. Our recommendation is to familiarize yourself with
using Seed by working through the tutorial included within this document. Detailed reference on more advanced topics is
provided and special attention should be given to the security section.

== Expectations

=== Docker and Linux Fundamentals

Before using Seed, you should have a working familiarity with developing code using modern tools, at minimum knowledge of 
Docker and Linux fundamentals. This guide is written with the assumption that you are using a Linux
workstation. The Seed CLI is heavily reliant on Docker to build and package Seed images (Docker image with Seed
metadata), so it is highly recommended that you have superuser (i.e. `sudo`) access. 

=== Algorithm Requirements

It is beneficial to identify and understand the following characteristics of each algorithm you intend to package with Seed:

* Software requirements (e.g. libraries, frameworks, and/or software dependencies needed)
* Hardware requirements (e.g. CPU and memory requirements, GPUs, etc.)
* Reference material or other support data 
* Licenses required

== Docker Installation

Refer to the Docker documentation for instructions on how to install Docker for your platform: https://docs.docker.com/install/

Depending on your IT environment, you may need to request an administrator install Docker for you.

The current version of Seed (1.2.1) requires Docker version 18.09 or newer.

To verify that installation was successful and confirm the Docker version, run the command `docker --version` from the terminal. 

[NOTE]
====
Depending on your environment, you may need to superuser privileges to execute the `docker` command; e.g. `sudo docker`. 
====

Output should be similar to the following:
```
docker version 19.03.8, build afacb8b
```

If this command fails, verify the Docker daemon is running using the `docker info` command. You can also use operating system 
utilities, such as `sudo systemctl is-active docker` or `sudo status docker` or `sudo service docker status`, or checking the 
service status using Windows utilities.

== Seed CLI Installation

The Seed CLI can be installed by downloading a binary from the releases page on GitHub: https://github.com/ngageoint/seed-cli/releases

Rename the downloaded binary file `seed` to match the usage in the rest of this guide.

Move the binary to your desired location on your filesystem:
```
mkdir /path/to/seed-dir  # e.g. mkdir /opt/seed
mv ./seed-darwin-amd64 /path/to/seed-dir/seed  # e.g. mv ./seed-darwin-amd64 /opt/seed/seed
```

If `~/.bash_profile` does not exist, create it: `touch ~/.bash_profile`. Open it in your desired text editor, and add the following line:
```
export PATH=$PATH:/path/to/seed-dir  # e.g. export PATH=$PATH:/opt/seed
```
Run `source ~/.bash_profile` to reload the profile.

To verify that installation was successful, run the command `seed` from the terminal. The Seed logo, usage instructions, and a list of commands should be displayed:

```
       .',,;;;;,,''''.
     .::::::::::;,,'.
    ,c:;;;;;::. ....
., .c;,;;::::. .,,,,,'.
'c;,;,;:::::. .,'''''',.      ';;;;;.   .;;;;;;;.   ;;;;;;;,   ,;;;;;,.
;:::,;::::;.  ,'''''''''     ::.   .    'c,        .::         ;c.   ;c'
,:;;,,'..    .,''''''','     ;:,.       'c'        .:;         ;:.   .:,
 ,:::,.     .,'''''''',.      .,;::,    ':;,,,     .::;,;.     ;:.   .c,
   ....''..','''''''',.           '::   'c'        .:;         ;:.   .:,
         .,'''''''','.      .;.   .c;   'c,        .c:.        ;c.  .;c.
         ,,,,,,,,,'.         ';;;;;'    .;;;;;;;.   ;;;;;;;,   ';;;;;,.
         ..'''...

Usage:	seed COMMAND

A tool for assisting in creating seed spec compliant algorithms

Commands:
  build 	Builds Seed compliant Docker image
  batch 	Executes Seed compliant docker image over multiple iterations
  init  	Initialize new project with example seed.manifest.json file
  list  	Lists all Seed compliant images residing on the local system
  publish	Publishes Seed compliant images to remote Docker registry
  pull		Pulls images from remote Docker registry
  run   	Executes Seed compliant Docker image
  search	Allows for discovery of Seed compliant images hosted within a Docker registry (default is docker.io)
  spec		Displays the specification for the current Seed version
  unpublish	Removes images from remote Docker registry
  validate	Validates a Seed spec
  version	Prints the version of Seed spec

Run 'seed COMMAND --help' for more information on a command.
```

== Tutorial

Following this step-by-step tutorial will quickly get you up and running with Seed and demonstrate the steps needed to
arrive at a complete Seed image. By the end of this guide, you will be able to:

- Build a Seed compliant algorithm
- Leverage the Seed CLI to ensure Seed compliance and build a Seed compliant Docker image
- Leverage the Seed CLI to test your Seed algorithm
- Leverage the Seed CLI to publish your Seed algorithm
- Understand next steps to automated distributed execution

=== Seed Compliance

For your algorithm to be compatible with Seed, it must satisfy the following criteria:

* *Run on Linux.* There is no language limitation other than it must be able to execute under Linux. You can use the
Docker base image of your choice. Alpine and CentOS are the preferred Linux flavors.
* *Command-line Invocation.* Seed provides input via either arguments or environment variables. If your algorithm is
prompting for input from a user, the job will continue to wait until it times out. This includes no display popups such
as error dialogs, file selection menus, splash screens, etc. In the event where a display device is required for
rendering data, a pseudo device must be used.
* *Configurable.* Your algorithm will be run in a standalone container, therefore absolute file paths must not be
embedded in the source code for your development environment. Necessary file paths should be passable into the algorithm
either via an environment variable or from the command line.
* *Reporting.* While this isnâ€™t required, it is ideal if your algorithm outputs its progress and errors to the
console and returns an appropriate exit code. Unique exit codes should be used for failures that can be anticipated. If
failures are not captured appropriately, Seed will only be able to identify a general algorithm error, which may make
debugging issues more difficult.

=== Sample Algorithm

The foundation of a Seed image is the algorithm that it contains. Everything that follows is informed by the
requirements of your unique algorithm: the inputs it requires, the outputs it generates and the resources that are
required to perform the computations. For this guide we are going to use a very simple algorithm, one which takes a
single file and dumps the first _N_ bytes as hexadecimal. We are going to output the bytes both to the console and write
them to a file. This example provides an example of how to accomplish the following:

* Accept a file input
* Accept an integer type input
* Write to the console
* Write to an output file

We are going to write our algorithm using basic Linux commands. Use your favorite text editor or IDE to create
`hex-dump.sh` file:

```
#!/usr/bin/env sh

## Usage:
## hex-dump.sh INPUT_FILE BYTE_COUNT OUTPUT_DUMP_FILE

INPUT_FILE=$1
BYTE_COUNT=$2
OUTPUT_DUMP_FILE=$3

echo "Invoked with command line: $*"

head -c $BYTE_COUNT $INPUT_FILE | od -x | tee $OUTPUT_DUMP_FILE

echo "Execution complete."
```

On Linux, this script can be executed immediately, but we are going to package in a Docker image. Create the following
`Dockerfile` in a directory adjacent to the above script:

```
FROM busybox

COPY hex-dump.sh /
```

With these 2 files, we can create our initial Docker containerized sample algorithm. Issue the following terminal
commands to build and run:

```
sudo docker build -t test .
sudo docker run --rm test sh hex-dump.sh hex-dump.sh 5 output-file.txt
```

You can see what this would look like at the command line:

```
Invoked with command line: hex-dump.sh 5 output-file.txt
0000000 2123 752f 0073
0000005
Execution complete.
```

Let's recap what we've done here.

1. We wrote a simple script that consumes 3 positional parameters: input file path, byte count, and output file path
1. Our script invokes a few basic linux executables to extract the number of bytes specified on the command line and
output them to the console and write them to a file.
1. We wrote a basic Dockerfile that identified a base image and copied our script into it.
1. We build a Docker image of our own and called it `test`.
1. Finally, we launch a container from our `test` image and passed it the required positional parameters directly.

There are some observations we should make about what we just accomplished.

1. We consumed the script we wrote as the input. The primary reason for this is so that we didn't have to concern
ourselves with getting a data file into the running container. This would have required a Docker volume mount.
1. We prefixed our call to the script with `sh` so that we didn't have to worry about setting the execute bit properly.
1. We did not validate that the `output-file.txt` was written. It exists within the container, but since we used `--rm`
flag with our docker command, the container was removed upon command completion.

With the `test` Docker image created, we could share this with other people on our local machine. We could also tag it
and push it to a remote registry (hub.docker.com, quay.io, etc.) and others would be able to run it. For our basic
algorithm example, this is fairly simple, but what if we have a more complicated algorithm with specific resource
requirements? What if our algorithm requires large supporting reference datasets? What if we need to leverage runtime
licenses that must be carefully protected? What if we want all of these requirements to be explicitly documented and
transparent to the consumers of your algorithm? This is where Seed provides what you need.

=== Seed Initialization

Continuing on from our previously crafted sample algorithm, let's get started with the definition of the basic Seed
manifest. A Seed manifest is the document that defines what your algorithm's purpose is, who created it, the interface
your algorithm provides, and what resource requirements it has. When you are building a Seed image your
`seed.manifest.json` will commonly reside next to your projects `Dockerfile`. To simplify the initial construction of
this file you can use the `seed init` command from within your code directory:

```
Created Seed file: /Users/user/code/seed/guide/example/seed.manifest.json
```

The newly-created `seed.manifest.json` file includes all common sections of the manifest and can be revised to properly 
reflect your specific algorithm. Let's start by updating the manifest for our sample algorithm to match the following:

```
{
  "seedVersion": "1.0.0",
  "job": {
    "name": "file-as-hex",
    "jobVersion": "1.0.0",
    "packageVersion": "1.0.0",
    "title": "File as Hex",
    "description": "Reads any arbitrary file and writes and prints N bytes as their hexadecimal representation",
    "maintainer": {
      "name": "Jonathan Meyer",
      "organization": "Applied Information Sciences",
      "email": "jonathan.meyer@appliedis.com"
    },
    "timeout": 3600,
    "interface": {
      "command": "sh hex-dump.sh ${INPUT_FILE} ${BYTE_COUNT} ${OUTPUT_DIR}/output.txt",
      "inputs": {
        "files": [
          {
            "name": "INPUT_FILE",
            "required": true
          }
        ],
        "json": [
          {
            "name": "BYTE_COUNT",
            "type": "integer",
            "required": true
          }
        ]
      },
      "outputs": {
        "files": [
          {
            "name": "OUTPUT_FILE",
            "pattern": "*.txt"
          }
        ]
      }
    },
    "resources": {
      "scalar": [
        { "name": "cpus", "value": 0.1 },
        { "name": "mem", "value": 128.0, "inputMultiplier": 2.0 }
      ]
    }
  }
}
```

There are a number of specific settings we made here that are worth highlighting:

1. `job.interface.command`. This setting is the crux of the manifest and defines exactly what command is issued on
container launch. As you can see, it mirrors the Docker command we ran in the previous section. The primary difference
now is the use of environment variables. These variable names correspond to the `name` values within the
`job.interface.inputs` and `job.interface.outputs` objects. If an `ENTRYPOINT` is specified in the Dockerfile, the 
contents of this setting will be passed to it.
1. `${INPUT_FILE}`. The Seed specification contract ensures that this variable will be populated with an absolute path
to the input since we have marked it as a required input.
1. `${BYTE_COUNT}`. The Seed specification contract ensures that this variable will be populated with an integer value
to the input since we have given it an explicit type and marked it as a required input.
1. `${OUTPUT_DIR}`. Seed provides some contextual values that ensure there are consistent locations for output capture. 
The `OUTPUT_DIR` environment variable is provided to all jobs and any file products must be placed under this location. 
The `pattern` expression for `OUTPUT_FILE` is rooted at `OUTPUT_DIR` and all patterns defined are relative to that 
location. This is why we tell our job to write to `${OUTPUT_DIR}/output.txt` and our `pattern` is defined as `*.txt`. 
1. `job.resources.scalar`. A considerable advantage of using Seed CLI is that it can emulate the resource
constraints that will be placed on your algorithm in a cluster environment. We've given a fractional CPU requirement and
small amount of memory. The one point of interest here is use of the `inputMultiplier` setting. This informs Seed to
allocate memory (MiBs) in proportion to the total size of inputs files (MiBs). In other words, if our `INPUT_FILE` is 4
MiBs the allocated memory will be: 128.0 MiBs + (2.0 * 4 MiBs) = 136 MiBs.
*REF ADDITIONAL VARIABLES*

[TIP]
====
In this example, we have named our output file `output.txt`. For an actual algorithm, we recommend using a more unique name 
or having the algorithm generate the name of the output file to help distinguish it from other outputs.
====  

=== Validate & Build

Providing validation and injection of the Seed manifest when building the final product is critical to ensuring
adherence to the {seed-spec-url}[specification]. The CLI allows you to validate a standalone manifest file, as well as apply 
validation as part of the build process. Let's perform a build of our job at this point to see this in action:

```
seed build
```

[NOTE]
====
The `seed build` command will automatically detect and use a Dockerfile and Seed manifest file in the current directory. 
Alternatively, the `-D` or `-dockerfile` and `-M` or `-manifest` options can be used to specify a path to a Dockerfile 
and/or manifest file, respectively.
====

The first step of the build is to apply validation. We can see the file that is being validated against the schema. We
are also informed that our resources section does not contain all the recommended resource objects:

```
INFO: Validating seed manifest file /Users/user/code/seed/guide/example/seed.manifest.json against schema...
INFO: Checking for variable name collisions...
WARNING: /Users/user/code/seed/guide/example/seed.manifest.json does not specify some recommended resources
Specifying cpu, memory and disk requirements are highly recommended
The following resources are not defined: [disk]
SUCCESS: No errors found. /Users/user/code/seed/guide/example/seed.manifest.json is valid.
```

Our build did successfully complete and we can see the `com.ngageoint.seed.manifest` LABEL that contains our serialized manifest in 
Step 3/3 of the Docker build process, as well as the `seed run` command in the final line of the output:

```
INFO: Building file-as-hex-1.0.0-seed:1.0.0
dockerfile: .
INFO: Running Docker command:
docker build -t file-as-hex-1.0.0-seed:1.0.0 /Users/matt/code/seed/seed-algorithm-test --label com.ngageoint.seed.manifest="{\"seedVersion\":\"1.0.0\",\"job\":{\"name\":\"file-as-hex\",\"jobVersion\":\"1.0.0\",\"packageVersion\":\"1.0.0\",\"title\":\"File as Hex\",\"description\":\"Reads any arbitrary file and writes and prints N bytes as their hexadecimal representation\",\"maintainer\":{\"name\":\"Jonathan Meyer\",\"organization\":\"Applied Information Sciences\",\"email\":\"jonathan.meyer@appliedis.com\"},\"timeout\":3600,\"interface\":{\"command\":\"sh hex-dump.sh \${INPUT_FILE} \${BYTE_COUNT} \${OUTPUT_DIR}\/output.txt\",\"inputs\":{\"files\":[{\"name\":\"INPUT_FILE\",\"required\":true}],\"json\":[{\"name\":\"BYTE_COUNT\",\"type\":\"integer\",\"required\":true}]},\"outputs\":{\"files\":[{\"name\":\"OUTPUT_FILE\",\"pattern\":\"*.txt\"}]}},\"resources\":{\"scalar\":[{\"name\":\"cpus\",\"value\":0.1},{\"name\":\"mem\",\"value\":128.0,\"inputMultiplier\":2.0}]}}}"
Sending build context to Docker daemon   5.12kB
Step 1/3 : FROM busybox
 ---> 83aa35aa1c79
Step 2/3 : COPY hex-dump.sh /
 ---> Using cache
 ---> c0c57cb2208b
Step 3/3 : LABEL com.ngageoint.seed.manifest="{\"seedVersion\":\"1.0.0\",\"job\":{\"name\":\"file-as-hex\",\"jobVersion\":\"1.0.0\",\"packageVersion\":\"1.0.0\",\"title\":\"File as Hex\",\"description\":\"Reads any arbitrary file and writes and prints N bytes as their hexadecimal representation\",\"maintainer\":{\"name\":\"Jonathan Meyer\",\"organization\":\"Applied Information Sciences\",\"email\":\"jonathan.meyer@appliedis.com\"},\"timeout\":3600,\"interface\":{\"command\":\"sh hex-dump.sh \${INPUT_FILE} \${BYTE_COUNT} \${OUTPUT_DIR}\/output.txt\",\"inputs\":{\"files\":[{\"name\":\"INPUT_FILE\",\"required\":true}],\"json\":[{\"name\":\"BYTE_COUNT\",\"type\":\"integer\",\"required\":true}]},\"outputs\":{\"files\":[{\"name\":\"OUTPUT_FILE\",\"pattern\":\"*.txt\"}]}},\"resources\":{\"scalar\":[{\"name\":\"cpus\",\"value\":0.1},{\"name\":\"mem\",\"value\":128.0,\"inputMultiplier\":2.0}]}}}"
 ---> Running in f914ba865bc7
Removing intermediate container f914ba865bc7
 ---> 40f431bf9d7a
Successfully built 40f431bf9d7a
Successfully tagged file-as-hex-1.0.0-seed:1.0.0
INFO: Successfully built image. This image can be published with the following command:
seed publish -in file-as-hex-1.0.0-seed:1.0.0 -r my.registry.address
This image can be run with the following command:
seed run -rm -in file-as-hex-1.0.0-seed:1.0.0 -i INPUT_FILE=<file> -e BYTE_COUNT=<setting> -o <outdir>
seed run -rm -in file-as-hex-1.0.0-seed:1.0.0 -i INPUT_FILE=<file>  -e BYTE_COUNT=<setting>  -o <outdir>
```

Let's address the warning regarding disk resource by updating our manifest with a third object in the
`job.resources.scalar` array:

```
{
  "seedVersion": "1.0.0",
  "job": {
    ...<omitted for brevity>...
    "resources": {
      "scalar": [
        { "name": "cpus", "value": 0.1 },
        { "name": "mem", "value": 128.0, "inputMultiplier": 2.0 },
        { "name": "disk", "value": 10.0 } <-- new disk resource object
      ]
    }
  }
}
```

We added a minimal disk requirement of 10 MiBs to resolve the warning. This space is only to accommodate any
temporary storage needed as part of the job execution beyond the storage required to write the input files to disk -
that storage will already be accounted for by Seed. Since our job is merely performing an analysis over the file stream
we will not have any appreciable need for temporary storage.

Now that our manifest is updated, explicitly perform a validation to ensure our warnings are resolved:

```
seed validate
```

```
INFO: Validating seed manifest file /Users/user/code/seed/guide/example/seed.manifest.json against schema...
INFO: Checking for variable name collisions...
SUCCESS: No errors found. /Users/user/code/seed/guide/example/seed.manifest.json is valid.
```

With the warnings corrected, let's create a new build:

```
seed build
```

With a complete Seed image now created, we can continue on to run our job using the resulting Seed image. We can see
that the CLI is preparing us to run a common subsequent command with an example invocation:
`seed run -rm -in file-as-hex-1.0.0-seed:1.0.0 -i INPUT_FILE=<file>  -e BYTE_COUNT=<setting>  -o <outdir>`

=== Run

The `seed run` command provides the bulk of the functionality within the CLI and is where we can ensure our job is ready
to run in an operational environment. By leveraging `seed run` we can be confident that the job we publish behaves
consistently with how we defined our interface and requirements in the `seed.manifest.json`.
Let's try a simple example to demonstrate the information the command can provide to guide proper invocation:

```
$ seed run
INFO: Image name not specified. Attempting to use local manifest: .
INFO: Found manifest: /Users/user/code/seed/guide/example/seed.manifest.json
INFO: Retrieving seed manifest from file-as-hex-1.0.0-seed:1.0.0 LABEL=com.ngageoint.seed.manifest
normalName: INPUT_FILE
ERROR: Error occurred processing inputs arguments.
ERROR: Incorrect input data files key/values provided. -i arguments should be in the form:
  seed run -i KEY1=path/to/file1 -i KEY2=path/to/file2 ...
The following input file keys are expected, but were not provided:
  INPUT_FILE
```

*TODO: Update above snippet when the CLI is update to properly note all missing inputs*

The first three lines show how the `seed run` command inferred the image from our current directory because it contained 
a Seed manifest, which was then used to find the Seed image built from it. 

The next two lines beginning with `ERROR` show how the CLI is also able to identify the inputs that are required, but we 
failed to provide (in this case, `INPUT_FILE`). Let's specify these inputs and try again:

```
$ seed run -i INPUT_FILE=seed.manifest.json -j BYTE_COUNT=128
INFO: Image name not specified. Attempting to use manifest: .
INFO: Found manifest: /Users/user/code/seed/guide/example/seed.manifest.json
INFO: Retrieving seed manifest from file-as-hex-1.0.0-seed:1.0.0 LABEL=com.ngageoint.seed.manifest
normalName: INPUT_FILE
INFO: /Users/user/code/seed/guide/example/output-file-as-hex-1.0.0-seed_1.0.0-2019-11-20T08_08_17-05_00 not found; creating directory...
INFO: Running Docker command:
docker run -v /Users/user/code/seed/guide/example/seed.manifest.json:/Users/user/code/seed/guide/example/seed.manifest.json -e INPUT_FILE=/Users/user/code/seed/guide/example/seed.manifest.json -v /Users/user/code/seed/guide/example/output-file-as-hex-1.0.0-seed_1.0.0-2019-11-20T08_08_17-05_00:/Users/user/code/seed/guide/example/output-file-as-hex-1.0.0-seed_1.0.0-2019-11-20T08_08_17-05_00 -e OUTPUT_DIR=/Users/user/code/seed/guide/example/output-file-as-hex-1.0.0-seed_1.0.0-2019-11-20T08_08_17-05_00 -e BYTE_COUNT=128 -e ALLOCATED_CPUS=0.100000 -m 1025m -e ALLOCATED_MEM=1025 -e ALLOCATED_DISK=10.000000 file-as-hex-1.0.0-seed:1.0.0 sh hex-dump.sh /Users/user/code/seed/guide/example/seed.manifest.json 128 /Users/user/code/seed/guide/example/output-file-as-hex-1.0.0-seed_1.0.0-2019-11-20T08_08_17-05_00/output.txt
Invoked with command line: /Users/user/code/seed/guide/example/seed.manifest.json 128 /Users/user/code/seed/guide/example/output-file-as-hex-1.0.0-seed_1.0.0-2019-11-20T08_08_17-05_00/output.txt
0000000 0a7b 2020 7322 6565 5664 7265 6973 6e6f
0000020 3a22 2220 2e31 2e30 2230 0a2c 2020 6a22
0000040 626f 3a22 7b20 200a 2020 2220 616e 656d
0000060 3a22 2220 6966 656c 612d 2d73 6568 2278
0000100 0a2c 2020 2020 6a22 626f 6556 7372 6f69
0000120 226e 203a 3122 302e 302e 2c22 200a 2020
0000140 2220 6170 6b63 6761 5665 7265 6973 6e6f
0000160 3a22 2220 2e31 2e30 2230 0a2c 2020 2020
0000200
Execution complete.
INFO: file-as-hex-1.0.0-seed:1.0.0 run took 1.343549206s
INFO: Validating output files found under /Users/user/code/seed/guide/example/output-file-as-hex-1.0.0-seed_1.0.0-2019-11-20T08_08_17-05_00...
SUCCESS: 1 files found for output OUTPUT_FILE:
	/Users/user/code/seed/guide/example/output-file-as-hex-1.0.0-seed_1.0.0-2019-11-20T08_08_17-05_00/output.txt
```

A complete run of our job!  Let's review what the CLI has accomplished for us:

- A directory for output data was created prior to launch. The CLI creates a timestamped directory to avoid any name
collision during subsequent executions. This is mounted into the container from the host when the Docker container is
launched.
- `OUTPUT_DIR` environment variable is set on container launch to match the output volume that is being mounted at
runtime to capture output.
- The input file `seed.manifest.json` we specified is explicitly mounted into the container at run-time.
- `INPUT_FILE` environment variable is set on container launch to inject the absolute file path relative to the
container context. This is why we indicate inputs via environment variable syntax in our `job.interface.command` value
of the `seed.manifest.json`.
- `BYTE_COUNT` environment variable is set on container launch to inject the value we specify for our JSON input type.
- Complete `docker run` statement is output to help identify the exact invocation command Seed CLI uses to launch your
Seed image. You can see the resource requirements identified as environment variables as well. Typically resource 
requirements are not needed, but JVM applications may benefit from explict understanding of their memory constraints. 
- Following the output of our job, we can see the CLI validate that an output file was written in a location that
matches the pattern we defined under `job.interface.outputs.files`.

Now that we understand the basics of running and testing our job, we can use more advanced features of the 
`seed run` command to further validate performance or exercise it against different test input datasets. See the 
<<Use Cases>> section for more examples.

=== Publish

After testing our job, we will typically want to share it so that it can used by others. Seed supports various
registry backends commonly used in the Docker ecosystem. Docker Hub is a managed registry that makes it easy to publish
your Seed image without configuring any additional services of your own. Before you can publish, you will need to register
for an account at https://hub.docker.com, Once you've done that, we can continue.

The following command will publish our Seed built and tested image to Docker Hub:
*TODO: Simplify this command example once sane defaults are applied.*

```
$ seed publish -r index.docker.io -O dockerhub-username -u dockerhub-username -p "dockerhub-password"
INFO: Image name not specified. Attempting to use manifest: .
INFO: Found manifest: /Users/user/code/seed/guide/example/seed.manifest.json
WARNING! Using --password via the CLI is insecure. Use --password-stdin.
Docker login warning: WARNING! Using --password via the CLI is insecure. Use --password-stdin.

Login Succeeded
INFO: Tagging image file-as-hex-1.0.0-seed:1.0.0 as index.docker.io/dockerhub-username/file-as-hex-1.0.0-seed:1.0.0
INFO: Running Docker command:
docker tag file-as-hex-1.0.0-seed:1.0.0 index.docker.io/dockerhub-username/file-as-hex-1.0.0-seed:1.0.0
INFO: Performing docker push index.docker.io/dockerhub-username/file-as-hex-1.0.0-seed:1.0.0
INFO: Running Docker command:
docker push index.docker.io/dockerhub-username/file-as-hex-1.0.0-seed:1.0.0
The push refers to repository [docker.io/dockerhub-username/file-as-hex-1.0.0-seed]
156f2dc847e9: Pushed
a6d503001157: Mounted from library/busybox
1.0.0: digest: sha256:fc29e2201b87bc32a94c58afcebba45115bf930788c8d1b95f871a4de9356396 size: 734
INFO: Removing local image index.docker.io/dockerhub-username/file-as-hex-1.0.0-seed:1.0.0
INFO: Running Docker command:
docker rmi index.docker.io/dockerhub-username/file-as-hex-1.0.0-seed:1.0.0
Untagged: dockerhub-username/file-as-hex-1.0.0-seed:1.0.0
Untagged: dockerhub-username/file-as-hex-1.0.0-seed@sha256:fc29e2201b87bc32a94c58afcebba45115bf930788c8d1b95f871a4de9356396
```

As can be seen from the console, we are internally performing a number of operations to publish the image. We attach
an appropriate tag to the physical Docker image to comply with the specification that reflect the remote registry
`index.docker.io` and organization `dockerhub-username`. This is followed by a push of the image to the repository and cleanup 
of the remote tags. This leaves our local environment with only the image names we built for our use, which can be verified by 
running the `docker images` command.

[NOTE]
====
In the example above, we are pushing to our personal Docker hub account, where the organization is the same as the username. 
For other use cases, the organization may differ from the username; for example, where organization is `my-company` and 
username is `my-username`.
====

== Reference

=== Use Cases

==== Multi-file bundles

==== Reference Data

==== Secret Data

While Seed jobs should prefer the Inputs object for passing in data, the Settings object can be used to specify sensitive 
information for the job, such as a database password.

[WARNING]
Sensitive information, such as passwords, private keys, or other credentials should never been included as files or code 
in the Seed job. Always use the Settings object to inject these values.

Update the `job.interface` object in our manifest from the <<Tutorial>> with a `settings` object:

```
{
  "seedVersion": "1.0.0",
  "job": {
    ...<omitted for brevity>...
    "interface": {
      ...<omitted for brevity>...
      "settings": [
        {
          "name": "MY_SECRET_SETTING", 
          "secret": true 
        }
      ]
    }
  }
}
```

`MY_SECRET_SETTING` will be injected into the job as an environment variable at runtime. It can be specified as a environment 
variable when executing the job using `seed run`:

```
seed run -i INPUT_FILE=seed.manifest.json -j BYTE_COUNT=128 -e MY_SECRET_SETTING=<secret-value>
```

If the environment variable is ommitted from the `seed run` command, the Seed CLI will output an error: 

```
$ seed run -i INPUT_FILE=seed.manifest.json -j BYTE_COUNT=128
INFO: Image name not specified. Attempting to use manifest: .
INFO: Found manifest: /Users/user/code/seed/guide/example2/seed.manifest.json
INFO: Retrieving seed manifest from file-as-hex-1.0.0-seed:1.0.0 LABEL=com.ngageoint.seed.manifest
normalName: INPUT_FILE
INFO: /Users/user/code/seed/guide/example2/output-file-as-hex-1.0.0-seed_1.0.0-2020-04-21T14_37_21-04_00 not found; creating directory...
ERROR: Error occurred processing settings arguments.
ERROR: Incorrect setting key/values provided. -e arguments should be in the form:
  seed run -e SETTING=somevalue ...
The following settings are expected:
  MY_SECRET_SETTING

ERROR: Incorrect setting key/values provided. -e arguments should be in the form:
  seed run -e SETTING=somevalue ...
The following settings are expected:
  MY_SECRET_SETTING
  ```

When running the Seed job on a Scale cluster, secret names and values are input as part of the JobType definition in Scale. 
Scale then stores the secrets in a {vault-url}[HashiCorp Vault] secret store where they are only accessible by running jobs. 
The system will automatically retrieve any secrets defined in the Seed job and inject them at runtime. You can also contact 
the Scale team for assistance with adding JobTypes that contain secrets.

=== Security

=== Optimization

=== Best Practices

* *Log everything.* Not having direct access to the file system of your algorithm means your only means for feedback on
what is happening inside your container is through console output. Take full advantage of standard output / error to
indicate any progress or errors you wish visibility into. Some languages (such as Python) may require you to specify
that output should not be buffered until process exits. This will facilitate live viewing of output with longer running
processes.
* *Privilege step-down.* Docker images we use often are set to use the `root` user by default. This is not a good

=== Frequently Asked Questions (FAQs)

[float]
==== How do I use Docker?
Plenty of resources for learning about Docker can be found on the https://www.docker.com[Docker website]. The primary 
goal of this guide is to explain how to integrate an algorithm with Seed and not focus on how to build a Docker container.

[float]
==== What is this Seed image?
https://ngageoint.github.io/seed/[Seed] is a general {seed-spec-url}[standard] that was developed to aid in the discovery 
and running of self-contained algorithms. It is a JSON-defined manifest that is embedded into the Docker image as a label. 
It defines:

	* Algorithm - name, version, description
	* Developer - name, company, contact info
	* Inputs/Outputs - how many, what type
	* Hardware Requirements - CPUs, memory, disk
	* Error handling - data vs. algorithm errors
	* Environment variables
	* Mounts

[float]
==== Why not just add all the files in my directory to the Docker image?
The image should be as small as necessary. It is pulled across the network each time it runs on a node.  
Smaller images result in less network traffic.

[float]
==== Why not just increase the hardware resources as much as possible?  I want it to run fast.
It is critical to strike a balance between the minimum resources required to run the algorithm and acceptable runtimes. 
Scale depends on accurate requirements in order to efficiently schedule jobs on the cluster. If a job requests more resources 
than it uses, these resources are wasted as they cannot not be allocated to other jobs. In a cloud environment, wasted 
resources equate to wasted money. If a job's requirements depend on the input, the Seed manifest allows the user to specify 
a multiplicative value for the hardware request.

[float]
==== My algorithm requires some reference data, should I just embed it into the Docker image?
It depends. If the total size of the file(s) is sufficiently small; e.g. less than 100 MB, then add it into the Docker image. 
If it has larger requirements, such as a lookup directory, please work with the Scale team to create a mountable directory.

[float]
==== How to secure sensitive information like passwords inside my Docker image?
The Seed manifest allows the developer to define "Settings", which will be defined as environment variables at runtime. 
These "Settings" can be marked as "secret" and will be stored in {vault-url}[HashiCorp Vault]. The values 
for these environment variables are hidden from the API and are only injected at runtime. See <<Secret Data>> for more details.

[float]
==== Why should I define error codes?
The developer should properly capture and define errors in their code using exit codes.  The Seed manifest allows the developer 
to define specific error codes with name, description, and type (job vs. data). A data error indicates that the input data was 
invalid and the job **will never** be able to run it. All other errors are job errors and could potentially be resolved on future 
executions (re-queues/re-process). A third type, "System" errors, are reserved for the Scale framework.

[float]
==== How do I use exit codes in Python/Matlab/Java/etc.?
Code should use proper try/catch or if/else statements to identify the type of error. The code can exit with any value between 
0-255. **The zero value indicates successful run.** The exit code can be checked after a program finishes with "echo $?".

Common examples exiting with code 42:

Python: `sys.exit(42)`

Matlab: `exit(42)`

Java: `System.exit(42)`

C/C++: `exit(42)`

Shell: `exit 42`

[float]
==== My algorithm involves running Python code, followed by Matlab code, and finally C code. Should I put it all in one Docker image?
It depends. Does each step involve heavy processing or create time-consuming intermediate products? If so, they would be better as 
their own standalone jobs with its output products being passed to a subsequent step in a recipe. If the individual steps are relatively 
small (in runtime and resources), it can all run within a single container using something like a shell script to execute each step.

